# generated by fastapi-codegen:
#   filename:  OpenAPI.yaml
#   timestamp: 2025-02-16T02:44:10+00:00

from __future__ import annotations
from typing import List, Optional, Union
import re
from datetime import datetime
from fastapi import FastAPI, HTTPException, Query
from fastapi.exceptions import RequestValidationError
from passlib.hash import pbkdf2_sha256
from pymongo.errors import DuplicateKeyError, PyMongoError
from bson import ObjectId

#importing async way of connecting to MongoDB
from MongoClient_async import db, listings_collection

from models import (
    Field500ErrorResponse,
    ListingGetResponse,
    ListingGetResponse1,
    ListingsGetAllResponse,
    ListingsGetResponseItem,
    ListingsPostRequest,
    ListingsPostResponse,
    SignUpPostRequest,
    SignUpPostResponse,
    SignUpPostResponse1,
    SignUpPostResponse2,
)

app = FastAPI(
    title='UTM Marketplace API',
    description='API specification for a campus-wide marketplace app',
    version='1.0.0',
    servers=[
        {'url': 'https://api.utmmarketplace.com', 'description': 'Production Server'},
        {'url': 'http://localhost:5000', 'description': 'Local Development Server'},
    ],
)


@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request, exc):
    raise HTTPException(status_code=422, detail="Invalid request data body")

@app.get(
    '/listing/{listing_id}',
    response_model=ListingsGetResponseItem,
    responses={
        '400': {'model': ListingGetResponse},
        '404': {'model': ListingGetResponse1},
        '500': {'model': Field500ErrorResponse},
    },
)
async def get_listing(
    listing_id: str,
) -> Union[
    ListingsGetResponseItem, ListingGetResponse, ListingGetResponse1, Field500ErrorResponse]:
    """
    Retrieve a single listing by ID
    """
    try:
        # Validate ObjectId
        if not ObjectId.is_valid(listing_id):
            return ListingGetResponse(error="Invalid listing ID format. Must be a valid Id.")

        # Fetch listing from MongoDB
        listing = await listings_collection.find_one({"_id": ObjectId(listing_id)})

        # Check if listing exists
        if not listing:
            return ListingGetResponse1(error="Listing not found.")

        # Convert MongoDB document to Pydantic model
        return ListingsGetResponseItem(
            id=str(listing.get("_id"),
            title=listing.get("title"),
            price=listing.get("price"),
            description=listing.get("description"),
            seller_id=listing.get("seller_id"),
            pictures=listing.get("pictures", []),
            category=listing.get("category"),
            date_posted=listing.get("date_posted"),
            campus=listing.get("campus"),
        )

    except Exception as e:
        return Field500ErrorResponse(error="Internal Server Error. Please try again later.")


@app.get('/listings', 
    response_model=ListingsGetAllResponse, 
    responses={'500': {'model': Field500ErrorResponse}},
    )
async def get_listings(
    page: int = Query(1, description="Page number", ge=1),
    # limit: int = Query(10, description="Number of listings per page", ge=1, le=30),
) -> Union[ListingsGetAllResponse, Field500ErrorResponse]:
    """
    Retrieve all listings with pagination.
    """
    try:
        limit = 10
        # Calculate skip value for pagination
        skip = (page - 1) * limit

        # Fetch paginated listings from MongoDB

        # Works in PyMongo (Sync)
        # listings_collection.find({}, skip=10, limit=5)  
        
        # Async motor method:
        cursor = listings_collection.find().skip(skip).limit(limit)
        listings = await cursor.to_list(length=limit)  # Get `limit` documents

        # Get total count for pagination info
        total_count = await listings_collection.count_documents({})
        # Convert MongoDB documents to Pydantic models
        response_data = []
        for listing in listings:
            try:
                response_data.append(
                    ListingsGetResponseItem(
                        id=str(listing["_id"]),
                        title=listing["title"],
                        price=listing["price"],
                        description=listing.get("description"),
                        seller_id=listing["seller_id"],
                        pictures=listing.get("pictures", []),
                        condition=listing["condition"],
                        category=listing.get("category"),
                        date_posted=listing.get("date_posted"),  # need to decide on the date format
                        campus=listing.get("campus"),
                    )
                )
            except Exception as e:
#                 pass
                print(f"Skipping invalid listing {listing['_id']}: {e}")  # Log invalid listings
        
        return ListingsGetAllResponse(
            listings=response_data,
            total=total_count
        )
    except Exception as e:
        return Field500ErrorResponse(error="Internal Server Error. Please try again later.")


@app.post(
    '/listings',
    response_model=None,
    responses={
        '201': {'model': ListingsPostResponse},
        '500': {'model': Field500ErrorResponse},
    },
)
async def post_listings(
    body: ListingsPostRequest,
) -> Optional[Union[ListingsPostResponse, Field500ErrorResponse]]:
    """
    Create a new listing
    """
    try:
        # Prepare data for MongoDB
        listing_data = body.dict()
        listing_data["date_posted"] = datetime.utcnow().isoformat()  # Ensure date is handled properly

        # Insert into MongoDB
        result = await listings_collection.insert_one(listing_data)

        # Return the created listing
        return ListingsPostResponse(
            id=str(result.inserted_id),
            title=body.title,
            price=body.price,
            description=body.description,
            seller_id=body.seller_id,
            pictures=body.pictures,
            category=body.category,
            date_posted=listing_data["date_posted"],
            condition=body.condition,
            campus=body.campus,
        )

    except Exception as e:
        # print(f"An error occurred: {str(e)}")
        return Field500ErrorResponse(error="Internal Server Error. Please try again later.")

@app.post(
    '/sign-up',
    response_model=None,
    responses={
        '201': {'model': SignUpPostResponse},
        '400': {'model': SignUpPostResponse1},
        '409': {'model': SignUpPostResponse2},
    },
)
def post_sign_up(body: SignUpPostRequest) -> Optional[Union[SignUpPostResponse, SignUpPostResponse1, SignUpPostResponse2]]:
    """
    Sign up a new user
    """
    email = body.email
    password = body.password.get_secret_value()

    #Validate email
    if not bool(re.match(r"^[a-zA-Z0-9_.+-]+@(utoronto\.ca|mail\.utoronto\.ca)$", email)):
        raise HTTPException(status_code=400, detail="Invalid email format. Please use a UofT email.")
    
    #Hash password
    hashed_password = pbkdf2_sha256.hash(password)

    #Create user document
    user_data = {
        'email': email,
        'password': hashed_password,
    }

    #Send to DB
    try:
        result = db.users.insert_one(user_data)
        return {"user_id": str(result.inserted_id), "message": "User registered successfully."}
    except DuplicateKeyError:
        raise HTTPException(status_code=409, detail="Email already registered.")
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Internal server error: {str(e)}")
