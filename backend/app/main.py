# generated by fastapi-codegen:
#   filename:  OpenAPI.yaml
#   timestamp: 2025-02-16T02:44:10+00:00

from __future__ import annotations
from typing import List, Optional, Union
import re
from datetime import datetime
from fastapi import FastAPI, HTTPException, Query, Header
from fastapi.exceptions import RequestValidationError
from passlib.hash import pbkdf2_sha256
from pymongo.errors import DuplicateKeyError, PyMongoError
from bson import ObjectId

#importing async way of connecting to MongoDB
from MongoClient_async import db, listings_collection, users_collection

from models import (
    Field500ErrorResponse,
    ListingGetResponse,
    ListingGetResponse1,
    ListingsGetAllResponse,
    ListingsGetResponseItem,
    ListingsPostRequest,
    ListingsPostResponse,
    SignUpPostRequest,
    SignUpPostResponse,
    SignUpPostResponse1,
    SignUpPostResponse2,
)

app = FastAPI(
    title='UTM Marketplace API',
    description='API specification for a campus-wide marketplace app',
    version='1.0.0',
    servers=[
        {'url': 'https://api.utmmarketplace.com', 'description': 'Production Server'},
        {'url': 'http://localhost:5000', 'description': 'Local Development Server'},
    ],
)


@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request, exc):
    raise HTTPException(status_code=422, detail="Invalid request data body")

@app.get(
    '/listing/{listing_id}',
    response_model=ListingsGetResponseItem,
    responses={
        '400': {'model': ListingGetResponse},
        '404': {'model': ListingGetResponse1},
        '500': {'model': Field500ErrorResponse},
    },
)
async def get_listing(
    listing_id: str,
) -> Union[
    ListingsGetResponseItem, ListingGetResponse, ListingGetResponse1, Field500ErrorResponse]:
    """
    Retrieve a single listing by ID
    """
    try:
        # Validate ObjectId
        if not ObjectId.is_valid(listing_id):
            return ListingGetResponse(error="Invalid listing ID format. Must be a valid Id.")

        # Fetch listing from MongoDB
        listing = await listings_collection.find_one({"_id": ObjectId(listing_id)})

        # Check if listing exists
        if not listing:
            return ListingGetResponse1(error="Listing not found.")

        # Convert MongoDB document to Pydantic model
        return ListingsGetResponseItem(
            id=str(listing["_id"]),
            title=listing["title"],
            price=listing["price"],
            description=listing.get("description"),
            seller_id=listing["seller_id"],
            pictures=listing.get("pictures", []),
            category=listing.get("category"),
            date_posted=listing.get("date_posted"),
            campus=listing.get("campus"),
        )

    except Exception as e:
        return Field500ErrorResponse(error="Internal Server Error. Please try again later.")


@app.get('/listings', 
    response_model=ListingsGetAllResponse, 
    responses={'500': {'model': Field500ErrorResponse}},
    )
@app.get('/listings', response_model=ListingsGetAllResponse, responses={'500': {'model': Field500ErrorResponse}})
async def get_listings(
    limit: Optional[int] = Header(5, description="Number of listings per page"),
    next: Optional[str] = Header(None, description="Token for pagination")  # Ensure default is None
) -> Union[ListingsGetAllResponse, Field500ErrorResponse]:
    """
    Retrieve listings using cursor-based pagination.
    """
    try:
        # Ensure limit is within a reasonable range
        limit = min(max(limit, 1), 30)

        # Initialize query
        query = {}
        pipeline = []

        if next:
            try:
                query["_id"] = {"$gt": ObjectId(next)}
            except Exception as e:
                # print(f"Invalid ObjectId: {e}")  # Debugging print
                raise HTTPException(status_code=400, detail="Invalid next format.")
        pipeline.extend([
            {"$match": query},
            {"$sort": {"_id": 1}}
        ])

        pipeline.extend([
            {"$limit": limit + 1},
            {"$project": {
                "id": {"$toString": "$_id"},
                "title": 1,
                "price": 1,
                "description": 1,
                "seller_id": 1,
                "pictures": 1,
                "condition": 1,
                "category": 1,
                "date_posted": 1,
                "campus": 1,
                "paginationToken": {"$meta": "searchSequenceToken"} if next else None
            }}
        ])

        # Execute query
        cursor = listings_collection.aggregate(pipeline)
        listings = await cursor.to_list(length=limit + 1)
        
        if not listings:
            return ListingsGetAllResponse(listings=[], total=0, next_page_token=None)

        # Check if there is a next page
        has_next_page = len(listings) > limit
        if has_next_page:
            listings = listings[:-1]  # Remove extra document

        if has_next_page:
            next_page_token = str(listings[-1]["_id"]) 
        else:
            next_page_token = None

        # Convert documents to Pydantic models
        response_data = [
            ListingsGetResponseItem(
                id=str(listing["_id"]),
                title=listing["title"],
                price=listing["price"],
                description=listing.get("description"),
                seller_id=listing["seller_id"],
                pictures=listing.get("pictures", []),
                condition=listing["condition"],
                category=listing.get("category"),
                date_posted=listing.get("date_posted"),
                campus=listing.get("campus"),
            )
            for listing in listings
        ]

        return ListingsGetAllResponse(
            listings=response_data,
            total=len(response_data),
            next_page_token=next_page_token
        )

    except Exception as e:
        return Field500ErrorResponse(error=f"Internal Server Error")


@app.post(
    '/listings',
    response_model=None,
    responses={
        '201': {'model': ListingsPostResponse},
        '500': {'model': Field500ErrorResponse},
    },
)
async def post_listings(
    body: ListingsPostRequest,
) -> Optional[Union[ListingsPostResponse, Field500ErrorResponse]]:
    """
    Create a new listing
    """
    try:
        # Prepare data for MongoDB
        listing_data = body.dict()
        listing_data["date_posted"] = datetime.utcnow().isoformat()  # Ensure date is handled properly

        # Insert into MongoDB
        result = await listings_collection.insert_one(listing_data)

        # Return the created listing
        return ListingsPostResponse(
            id=str(result.inserted_id),
            title=body.title,
            price=body.price,
            description=body.description,
            seller_id=body.seller_id,
            pictures=body.pictures,
            category=body.category,
            date_posted=listing_data["date_posted"],
            condition=body.condition,
            campus=body.campus,
        )
    

    except Exception as e:
        # print(f"An error occurred: {str(e)}")
        return Field500ErrorResponse(error="Internal Server Error. Please try again later.")


@app.post(
    '/sign-up',
    response_model=None,
    responses={
        '201': {'model': SignUpPostResponse},
        '400': {'model': SignUpPostResponse1},
        '409': {'model': SignUpPostResponse2},
    },
)
async def post_sign_up(body: SignUpPostRequest) -> Optional[Union[SignUpPostResponse, SignUpPostResponse1, SignUpPostResponse2]]:
    """
    Sign up a new user
    """
    email = body.email
    password = body.password.get_secret_value()

    #Validate email
    if not bool(re.match(r"^[a-zA-Z0-9_.+-]+@(utoronto\.ca|mail\.utoronto\.ca)$", email)):
        raise HTTPException(status_code=400, detail="Invalid email format. Please use a UofT email.")
    
    #Hash password
    hashed_password = pbkdf2_sha256.hash(password)

    #Create user document
    user_data = {
        'email': email,
        'password': hashed_password,
    }

    #Send to DB
    try:
        # result = db.users.insert_one(user_data)
        result = await users_collection.insert_one(user_data)
        return {"user_id": str(result.inserted_id), "message": "User registered successfully."}
    except DuplicateKeyError:
        raise HTTPException(status_code=409, detail="Email already registered.")
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Internal server error: {str(e)}")