# generated by fastapi-codegen:
#   filename:  OpenAPI.yaml
#   timestamp: 2025-02-16T02:44:10+00:00

from __future__ import annotations
from typing import List, Optional, Union
import re
from datetime import datetime
from fastapi import FastAPI, HTTPException, Query
from passlib.hash import pbkdf2_sha256
from pymongo.errors import DuplicateKeyError, PyMongoError
from bson import ObjectId

from models import (
    ListingGetResponse,
    ListingGetResponse1,
    ListingsGetResponseItem,
    ListingsGetAllResponse,
    ListingsPostRequest,
    ListingsPostResponse,
    SignUpPostRequest,
    SignUpPostResponse,
    SignUpPostResponse1,
    SignUpPostResponse2,
)

from connect_db import db  # Import MongoDB connection

app = FastAPI(
    title='UTM Marketplace API',
    servers=[
        {'url': 'http://localhost:8000', 'description': 'Local Development Server'},
    ],
)

@app.get("/listing", response_model=ListingsGetResponseItem,
         responses={
            '400': {'model': ListingGetResponse},
            '404': {'model': ListingGetResponse1},
         })
def get_listing(listingid: str = Query(..., description="Listing ID to retrieve")):
    """
    Retrieve a single listing by its listing ID
    """
    try:
        # Validate listingid as a valid MongoDB ObjectId
        if not ObjectId.is_valid(listingid):
            raise HTTPException(status_code=400, detail="Invalid listing ID format.")

        # Fetch listing from MongoDB
        listing = db.listings.find_one({"_id": ObjectId(listingid)})

        if not listing:
            raise HTTPException(status_code=404, detail="Listing not found.")

        # Convert MongoDB document to response model
        return ListingsGetResponseItem(
            id=str(listing["_id"]),
            title=listing.get("title"),
            price=listing.get("price"),
            description=listing.get("description"),
            seller_id=listing.get("user_id")  # Assuming `user_id` is the seller_id
        )

    except PyMongoError as e:
        raise HTTPException(status_code=500, detail=f"Database error: {str(e)}")
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Unexpected error: {str(e)}")
    

@app.get('/listings', response_model=ListingsGetAllResponse)
def get_listings() -> ListingsGetAllResponse:
    """
    Retrieve all listings
    """
    try:
        # Fetch all listings from MongoDB
        listings_cursor = db.listings.find({})
        
        # Convert MongoDB documents to Pydantic models
        listings = [
            ListingsGetResponseItem(
                id=str(listing["_id"]),  # Convert ObjectId to string
                title=listing.get("title"),
                price=listing.get("price"),
                description=listing.get("description"),
                seller_id=listing.get("user_id")
            )
            for listing in listings_cursor
        ]

        return listings

    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Unexpected error: {str(e)}")


@app.post(
    '/listings', response_model=None, responses={'201': {'model': ListingsPostResponse}}
)
def post_listings(body: ListingsPostRequest) -> Optional[ListingsPostResponse]:
    """
    Create a new listing
    """
    try:
        # Prepare listing document
        listing_data = body.dict()
        listing_data["date_posted"] = datetime.utcnow().isoformat()

        # Insert into MongoDB
        result = db.listings.insert_one(listing_data)

        if not result.inserted_id:
            raise HTTPException(status_code=500, detail="Listing failed to post")

        return ListingsPostResponse(
            id=str(result.inserted_id),
            title=body.title,
            price=body.price,
            description=body.description,
            message="Listing created successfully."
        )

    except PyMongoError as e:
        raise HTTPException(status_code=500, detail=f"Database error: {str(e)}")
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Unexpected error: {str(e)}")


@app.post(
    '/sign-up',
    response_model=None,
    responses={
        '201': {'model': SignUpPostResponse},
        '400': {'model': SignUpPostResponse1},
        '409': {'model': SignUpPostResponse2},
    },
)
def post_sign_up(body: SignUpPostRequest) -> Optional[Union[SignUpPostResponse, SignUpPostResponse1, SignUpPostResponse2]]:
    """
    Sign up a new user
    """
    email = body.email
    password = body.password.get_secret_value()

    #Validate email
    if not bool(re.match(r"^[a-zA-Z0-9_.+-]+@(utoronto\.ca|mail\.utoronto\.ca)$", email)):
        raise HTTPException(status_code=400, detail="Invalid email format. Please use a UofT email.")
    
    #Hash password
    hashed_password = pbkdf2_sha256.hash(password)

    #Create user document
    user_data = {
        'email': email,
        'password': hashed_password,
    }

    #Send to DB
    try:
        result = db.users.insert_one(user_data)
        return {"user_id": str(result.inserted_id), "message": "User registered successfully."}
    except DuplicateKeyError:
        raise HTTPException(status_code=409, detail="Email already registered.")
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Internal server error: {str(e)}")